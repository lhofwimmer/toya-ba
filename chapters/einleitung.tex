\chapter{Einleitung}
\label{cha:Einleitung}

Compiler sind ein essenzieller Grundstein der Informatik und stellen das Bindeglied zwischen Mensch und Maschine dar. Erst durch Compiler ist die Entwicklung von höheren Programmiersprachen und Programmen in einer Größenordnung möglich, die den Anforderungen des 21. Jahrhunderts gerecht werden. Ohne Compiler wäre die kommerzielle Entwicklung von Software unvorstellbar. Sie sind eine logische Konsequenz, den Anforderungen nach immer effizienter werdenden Anwendungen nachzukommen. Compiler sind die Brücke zwischen Maschinencode und dem Menschen. So weit, dass die Anweisungen an den Computer in Programmiersprachen wie SQL beinahe Englischen Sätzen entsprechen. Im Zeitalter der kollaborativen Entwicklung gilt es, Programme nicht nur zu schreiben, sondern auch für sich selbst und Kolleg:innen lesbar zu machen. All diese Aspekte laufen darauf hinaus, dass Compiler die einzige Lösung sind.

Dementsprechend ist es elementar, die Funktionsweisen und Abläufe von Compilern zu verstehen. Der beste Weg, um dies zu bewerkstelligen, ist einen Compiler selbst zu entwickeln.

\section{Zielsetzung}

Ziel dieser Arbeit ist es, eine neue Programmiersprache und einen entsprechenden Compiler dafür zu entwickeln. Dieser Compiler erzeugt Bytecode für die Java Virtual Machine, um \toya-Programme anschließend plattformunabhängig ausführen zu können. \Toya soll die Definition von Funktionen, primitiven Variablen und Feldern und Kontrollflüssen in Form von Verzweigungen und Schleifen erlauben. Daraus ergibt sich eine Turing-vollständige Programmiersprache, aus welcher heraus theoretisch alle anderen Programmiersprachen entstehen könnten. \Toya orientiert sich syntaktisch an Programmiersprachen wie C und Java mit einem Fokus auf Simplizität.

\section{Wieso die JVM?}

Eine grundsätzliche Frage, die es vor der eigentlichen Arbeit zu beantworten gilt, ist ob das Kompilat des \toya Compilers Maschinencode oder ein Zwischenprodukt in Form von Bytecode für eine virtuelle Maschine produzieren soll. Während der native Ansatz mit Maschinencode eine höhere Ausführungsgeschwindigkeit mit sich bringt, kommt der Nachteil der Implementierungskomplexität des Compilers dazu.

Virtuelle Maschinen hingegen bieten eine Abstraktionsschicht über dem Maschinencode und machen die Entwicklung eines Compilers daher wesentlich leichter. Das ermöglicht, den Fokus auf andere Aspekte, wie die Verarbeitung des Syntaxbaumes und die Generierung des Bytecodes zu legen; was auch im Verlauf dieser Arbeit klar zu erkennen ist.

Damit ist klar erkennbar, dass eine virtuelle Maschine die Ausgabe des Compilers interpretieren soll. Unklar ist jedoch weiterhin, welche virtuelle Maschine das Ziel sein soll. Aufgrund der Menge an verfügbaren Resourcen, beschränkt sich die Auswahl auf die Java Virtual Machine und Common Language Runtime. Zweiteres bringt einige Vorteile, wie zum Beispiel, dass Typinformationen generischer Typen zur Laufzeit erhalten bleiben. \Toya nutzt jedoch nur einen Bruchteil aller möglichen Eigenschaften, weswegen dies keine entscheidende Rolle spielt. Schlussendlich fällt die Entscheidung auf die Java Virtual Machine aufgrund der Familiarität damit. Eine Implementierung für die Common Language Runtime ist jedoch ebenso umsetzbar.

\section{Aufbau der Arbeit}

Die Arbeit beschäftigt sich zuerst mit den theoretischen Grundlagen von \toya und den Werkzeugen, denen \toya zugrunde liegt. Anschließend werden konkrete Implementierungsdetails präsentiert und die Funktionalität der Sprache anhand von Beispielen bewiesen.

Das Kapitel \nameref{cha:toya} umfasst die Spezifikation von \toya, ohne jedoch auf Implementierungsdetails einzugehen. Anschließend kommt es im Kapitel \nameref{cha:comparison} zur Gegenüberstellung mit einer etablierten Programmiersprache. Hierbei wurde Kotlin gewählt, da es sich dabei um die Implementierungssprache des \toya Compilers handelt. Die Kapitel \nameref{cha:antlr} und \nameref{cha:jvm} bieten eine theoretische Beschreibung von ANTLR und der JVM. Das Kapitel \nameref{cha:implementation} behandelt Implementierungsdetails des Compilers und bietet einen konkreten Einblick in die Architektur anhand von Codebeispielen und Diagrammen. \nameref{cha:tests} zeigt die Funktionalität von \toya anhand von konkreten Codebeispielen und deren Ausgaben. In \nameref{cha:Schluss} wird über das Ergebnis reflektiert und weitere Schritte erläutert.